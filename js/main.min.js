var B = Object.defineProperty,
    V = Object.getOwnPropertySymbols,
    W = Object.prototype.hasOwnProperty,
    Y = Object.prototype.propertyIsEnumerable,
    L = (e, t, r) => (t in e ? B(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : (e[t] = r)),
    x = (e, t) => {
        for (var r in t || (t = {})) W.call(t, r) && L(e, r, t[r]);
        if (V) for (var r of V(t)) Y.call(t, r) && L(e, r, t[r]);
        return e;
    },
    d = (e, t, r) => (L(e, "symbol" != typeof t ? t + "" : t, r), r);
!(function (e, t) {
    "object" == typeof exports && "undefined" != typeof module ? (module.exports = t()) : "function" == typeof define && define.amd ? define(t) : ((e = "undefined" != typeof globalThis ? globalThis : e || self).JustValidate = t());
})(this, function () {
    "use strict";
    const e = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
        t = /^[0-9]+$/,
        r = /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/,
        i = /^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/;
    var o, l, s, a;
    ((l = o || (o = {})).Required = "required"),
        (l.Email = "email"),
        (l.MinLength = "minLength"),
        (l.MaxLength = "maxLength"),
        (l.Password = "password"),
        (l.Number = "number"),
        (l.MaxNumber = "maxNumber"),
        (l.MinNumber = "minNumber"),
        (l.StrongPassword = "strongPassword"),
        (l.CustomRegexp = "customRegexp"),
        (function (e) {
            e.Required = "required";
        })(s || (s = {})),
        (function (e) {
            (e.Label = "label"), (e.LabelArrow = "labelArrow");
        })(a || (a = {}));
    const n = (e) => !!e && "function" == typeof e.then,
        c = {
            errorFieldStyle: { color: "#b81111", border: "1px solid #B81111" },
            errorFieldCssClass: "just-validate-error-field",
            errorLabelStyle: { color: "#b81111" },
            errorLabelCssClass: "just-validate-error-label",
            focusInvalidField: !0,
            lockForm: !0,
            testingMode: !1,
        };
    return class {
        constructor(e, t, r) {
            d(this, "form", null),
                d(this, "fields", {}),
                d(this, "groupFields", {}),
                d(this, "errors", {}),
                d(this, "isValid", !1),
                d(this, "isSubmitted", !1),
                d(this, "globalConfig", c),
                d(this, "errorLabels", []),
                d(this, "eventListeners", []),
                d(this, "dictLocale", []),
                d(this, "currentLocale"),
                d(this, "customStyleTags", {}),
                d(this, "onSuccessCallback"),
                d(this, "onFailCallback"),
                d(this, "tooltips", []),
                d(this, "lastScrollPosition"),
                d(this, "isScrollTick"),
                d(this, "refreshAllTooltips", () => {
                    this.tooltips.forEach((e) => {
                        e.refresh();
                    });
                }),
                d(this, "handleDocumentScroll", () => {
                    (this.lastScrollPosition = window.scrollY),
                        this.isScrollTick ||
                            (window.requestAnimationFrame(() => {
                                this.refreshAllTooltips(), (this.isScrollTick = !1);
                            }),
                            (this.isScrollTick = !0));
                }),
                d(this, "formSubmitHandler", (e) => {
                    e.preventDefault(),
                        (this.isSubmitted = !0),
                        this.globalConfig.lockForm && this.lockForm(),
                        this.validate().then(() => {
                            var t, r;
                            this.isValid ? null == (t = this.onSuccessCallback) || t.call(this, e) : null == (r = this.onFailCallback) || r.call(this, this.fields), this.globalConfig.lockForm && this.unlockForm();
                        });
                }),
                d(this, "handleFieldChange", (e) => {
                    let t, r;
                    for (const i in this.fields) {
                        const o = this.fields[i];
                        if (o.elem === e) {
                            (t = o), (r = i);
                            break;
                        }
                    }
                    !t || !r || this.validateField(r, t, !0);
                }),
                d(this, "handleGroupChange", (e) => {
                    let t, r;
                    for (const i in this.groupFields) {
                        const o = this.groupFields[i];
                        if (o.elems.find((t) => t === e)) {
                            (t = o), (r = i);
                            break;
                        }
                    }
                    !t || !r || this.validateGroup(r, t);
                }),
                d(this, "handlerChange", (e) => {
                    !e.target || (this.handleFieldChange(e.target), this.handleGroupChange(e.target), this.renderErrors());
                }),
                this.initialize(e, t, r);
        }
        initialize(e, t, r) {
            if (
                ((this.form = null),
                (this.errors = {}),
                (this.isValid = !1),
                (this.isSubmitted = !1),
                (this.globalConfig = c),
                (this.errorLabels = []),
                (this.eventListeners = []),
                (this.customStyleTags = {}),
                (this.tooltips = []),
                "string" == typeof e)
            ) {
                const t = document.querySelector(e);
                if (!t) throw Error(`Form with ${e} selector not found! Please check the form selector`);
                this.setForm(t);
            } else {
                if (!(e instanceof HTMLFormElement)) throw Error("Form selector is not valid. Please specify a string selector or a DOM element.");
                this.setForm(e);
            }
            if (((this.globalConfig = x(x({}, c), t)), r && (this.dictLocale = r), this.isTooltip())) {
                const e = document.createElement("style");
                (e.textContent =
                    ".just-validate-error-label[data-tooltip=true]{position:fixed;padding:4px 8px;background:#423f3f;color:#fff;white-space:nowrap;z-index:10;border-radius:4px;transform:translateY(-5px)}.just-validate-error-label[data-tooltip=true]:before{content:'';width:0;height:0;border-left:solid 5px transparent;border-right:solid 5px transparent;border-bottom:solid 5px #423f3f;position:absolute;z-index:3;display:block;bottom:-5px;transform:rotate(180deg);left:calc(50% - 5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]{transform:translateX(-5px)}.just-validate-error-label[data-tooltip=true][data-direction=left]:before{right:-7px;bottom:auto;left:auto;top:calc(50% - 2px);transform:rotate(90deg)}.just-validate-error-label[data-tooltip=true][data-direction=right]{transform:translateX(5px)}.just-validate-error-label[data-tooltip=true][data-direction=right]:before{right:auto;bottom:auto;left:-7px;top:calc(50% - 2px);transform:rotate(-90deg)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]{transform:translateY(5px)}.just-validate-error-label[data-tooltip=true][data-direction=bottom]:before{right:auto;bottom:auto;left:calc(50% - 5px);top:-5px;transform:rotate(0)}"),
                    (this.customStyleTags[a.Label] = document.head.appendChild(e)),
                    this.addListener("scroll", document, this.handleDocumentScroll);
            }
        }
        getLocalisedString(e) {
            var t;
            return (this.currentLocale && this.dictLocale.length && (null == (t = this.dictLocale.find((t) => t.key === e)) ? void 0 : t.dict[this.currentLocale])) || e;
        }
        getFieldErrorMessage(e) {
            return (
                this.getLocalisedString(e.errorMessage) ||
                ((e, t) => {
                    switch (e) {
                        case o.Required:
                            return "The field is required";
                        case o.Email:
                            return "Email has invalid format";
                        case o.MaxLength:
                            return "The field must contain a maximum of :value characters".replace(":value", String(t));
                        case o.MinLength:
                            return "The field must contain a minimum of :value characters".replace(":value", String(t));
                        case o.Password:
                            return "Password must contain minimum eight characters, at least one letter and one number";
                        case o.Number:
                            return "Value should be a number";
                        case o.StrongPassword:
                            return "Password should contain minimum eight characters, at least one uppercase letter, one lowercase letter, one number and one special character";
                        case o.MaxNumber:
                            return "Number should be less or equal than :value".replace(":value", String(t));
                        case o.MinNumber:
                            return "Number should be more or equal than :value".replace(":value", String(t));
                        default:
                            return "Value is incorrect";
                    }
                })(e.rule, e.value)
            );
        }
        getGroupErrorMessage(e) {
            return this.getLocalisedString(e.errorMessage) || ((e) => (e === s.Required ? "The field is required" : "Group is incorrect"))(e.rule);
        }
        setFieldInvalid(e, t) {
            (this.fields[e].isValid = !1), (this.fields[e].errorMessage = this.getFieldErrorMessage(t));
        }
        setGroupInvalid(e, t) {
            (this.groupFields[e].isValid = !1), (this.groupFields[e].errorMessage = this.getGroupErrorMessage(t));
        }
        setGroupValid(e) {
            this.groupFields[e].isValid = !0;
        }
        getElemValue(e) {
            return "checkbox" === e.type ? e.checked : e.value;
        }
        validateGroupRule(e, t, r, i) {
            if (i.rule === s.Required) ("radio" === t || "checkbox" === t) && (r.every((e) => !e.checked) ? this.setGroupInvalid(e, i) : this.setGroupValid(e));
        }
        validateFieldRule(l, s, a, c = !1) {
            const d = a.value,
                u = this.getElemValue(s);
            switch (a.rule) {
                case o.Required:
                    ((e) => {
                        let t = e;
                        return "string" == typeof e && (t = e.trim()), !t;
                    })(u) && this.setFieldInvalid(l, a);
                    break;
                case o.Email:
                    if ("string" != typeof u) {
                        this.setFieldInvalid(l, a);
                        break;
                    }
                    ((t) => e.test(t))(u) || this.setFieldInvalid(l, a);
                    break;
                case o.MaxLength:
                    if (!d) return console.error(`Value for ${a.rule} rule for [${l}] field is not defined. The field will be always invalid.`), void this.setFieldInvalid(l, a);
                    if ("number" != typeof d) return console.error(`Value for ${a.rule} rule for [${l}] should be a number. The field will be always invalid.`), void this.setFieldInvalid(l, a);
                    if ("string" != typeof u) {
                        this.setFieldInvalid(l, a);
                        break;
                    }
                    ((e, t) => e.length > t)(u, d) && this.setFieldInvalid(l, a);
                    break;
                case o.MinLength:
                    if (!d) return console.error(`Value for ${a.rule} rule for [${l}] field is not defined. The field will be always invalid.`), void this.setFieldInvalid(l, a);
                    if ("number" != typeof d) return console.error(`Value for ${a.rule} rule for [${l}] should be a number. The field will be always invalid.`), void this.setFieldInvalid(l, a);
                    if ("string" != typeof u) {
                        this.setFieldInvalid(l, a);
                        break;
                    }
                    ((e, t) => e.length < t)(u, d) && this.setFieldInvalid(l, a);
                    break;
                case o.Password:
                    if ("string" != typeof u) {
                        this.setFieldInvalid(l, a);
                        break;
                    }
                    ((e) => r.test(e))(u) || this.setFieldInvalid(l, a);
                    break;
                case o.StrongPassword:
                    if ("string" != typeof u) {
                        this.setFieldInvalid(l, a);
                        break;
                    }
                    ((e) => i.test(e))(u) || this.setFieldInvalid(l, a);
                    break;
                case o.Number:
                    if ("string" != typeof u) {
                        this.setFieldInvalid(l, a);
                        break;
                    }
                    ((e) => t.test(e))(u) || this.setFieldInvalid(l, a);
                    break;
                case o.MaxNumber: {
                    if (!d) return console.error(`Value for ${a.rule} rule for [${l}] field is not defined. The field will be always invalid.`), void this.setFieldInvalid(l, a);
                    if ("number" != typeof d) return console.error(`Value for ${a.rule} rule for [${l}] field should be a number. The field will be always invalid.`), void this.setFieldInvalid(l, a);
                    if ("string" != typeof u) {
                        this.setFieldInvalid(l, a);
                        break;
                    }
                    const e = +u;
                    (Number.isNaN(e) || ((e, t) => e > t)(e, d)) && this.setFieldInvalid(l, a);
                    break;
                }
                case o.MinNumber: {
                    if (!d) return console.error(`Value for ${a.rule} rule for [${l}] field is not defined. The field will be always invalid.`), void this.setFieldInvalid(l, a);
                    if ("number" != typeof d) return console.error(`Value for ${a.rule} rule for [${l}] field should be a number. The field will be always invalid.`), void this.setFieldInvalid(l, a);
                    if ("string" != typeof u) {
                        this.setFieldInvalid(l, a);
                        break;
                    }
                    const e = +u;
                    (Number.isNaN(e) || ((e, t) => e < t)(e, d)) && this.setFieldInvalid(l, a);
                    break;
                }
                case o.CustomRegexp: {
                    if (!d) return console.error(`Value for ${a.rule} rule for [${l}] field is not defined. This field will be always invalid.`), void this.setFieldInvalid(l, a);
                    let e;
                    try {
                        e = new RegExp(d);
                    } catch {
                        console.error(`Value for ${a.rule} rule for [${l}] should be a valid regexp. This field will be always invalid.`), this.setFieldInvalid(l, a);
                        break;
                    }
                    e.test(String(u)) || this.setFieldInvalid(l, a);
                    break;
                }
                default: {
                    if (!a.validator) return console.error(`Validator for custom rule for [${l}] field is not defined. This field will be always invalid.`), void this.setFieldInvalid(l, a);
                    if ("function" != typeof a.validator) return console.error(`Validator for custom rule for [${l}] field should be a function. This field will be always invalid.`), void this.setFieldInvalid(l, a);
                    const e = a.validator(u, this.fields);
                    if (("boolean" != typeof e && "function" != typeof e && console.error(`Validator return value for [${l}] field should be boolean or function. It will be cast to boolean.`), "function" == typeof e && !c)) {
                        const t = e();
                        return n(t)
                            ? t
                                  .then((e) => {
                                      e || this.setFieldInvalid(l, a);
                                  })
                                  .catch(() => {
                                      this.setFieldInvalid(l, a);
                                  })
                            : (console.error(`Validator function for custom rule for [${l}] field should return a Promise. This field will be always invalid.`), void this.setFieldInvalid(l, a));
                    }
                    e || this.setFieldInvalid(l, a);
                }
            }
        }
        validateField(e, t, r = !1) {
            t.isValid = !0;
            const i = [];
            return (
                [...t.rules].reverse().forEach((o) => {
                    const l = this.validateFieldRule(e, t.elem, o, r);
                    n(l) && i.push(l);
                }),
                Promise.allSettled(i)
            );
        }
        validateGroup(e, t) {
            const r = [];
            return (
                [...t.rules].reverse().forEach((i) => {
                    const o = this.validateGroupRule(e, t.type, t.elems, i);
                    n(o) && r.push(o);
                }),
                Promise.allSettled(r)
            );
        }
        focusInvalidField() {
            for (const e in this.fields) {
                const t = this.fields[e];
                if (!t.isValid) {
                    setTimeout(() => t.elem.focus(), 0);
                    break;
                }
            }
        }
        afterSubmitValidation() {
            this.renderErrors(), this.globalConfig.focusInvalidField && this.focusInvalidField();
        }
        validate() {
            return new Promise((e) => {
                const t = [];
                Object.keys(this.fields).forEach((e) => {
                    const r = this.fields[e],
                        i = this.validateField(e, r);
                    n(i) && t.push(i);
                }),
                    Object.keys(this.groupFields).forEach((e) => {
                        const r = this.groupFields[e],
                            i = this.validateGroup(e, r);
                        n(i) && t.push(i);
                    }),
                    t.length
                        ? Promise.allSettled(t).then(() => {
                              this.afterSubmitValidation(), e(!0);
                          })
                        : (this.afterSubmitValidation(), e(!1));
            });
        }
        setForm(e) {
            (this.form = e), this.form.setAttribute("novalidate", "novalidate"), this.removeListener("submit", this.form, this.formSubmitHandler), this.addListener("submit", this.form, this.formSubmitHandler);
        }
        addListener(e, t, r) {
            t.addEventListener(e, r), this.eventListeners.push({ type: e, elem: t, func: r });
        }
        removeListener(e, t, r) {
            t.removeEventListener(e, r);
        }
        addField(e, t, r) {
            if ("string" != typeof e) throw Error("Field selector is not valid. Please specify a string selector.");
            const i = document.querySelector(e);
            if (!i) throw Error(`Field with ${e} selector not found! Please check the field selector.`);
            if (!Array.isArray(t) || !t.length) throw Error(`Rules argument for the field [${e}] should be an array and should contain at least 1 element.`);
            return (
                t.forEach((t) => {
                    if (!("rule" in t) && !("validator" in t)) throw Error(`Rules argument for the field [${e}] must contain at least one rule or validator property.`);
                    if (!(t.validator || (t.rule && Object.values(o).includes(t.rule)))) throw Error(`Rule should be one of these types: ${Object.values(o).join(", ")}. Provided value: ${t.rule}`);
                }),
                (this.fields[e] = { elem: i, rules: t, isValid: void 0, config: r }),
                this.setListeners(i),
                this.isSubmitted && this.validate(),
                this
            );
        }
        removeField(e) {
            if ("string" != typeof e) throw Error("Field selector is not valid. Please specify a string selector.");
            return this.fields[e] ? (this.destroy(), delete this.fields[e], this.refresh(), this) : (console.error("Field not found. Check the field selector."), this);
        }
        addRequiredGroup(e, t, r) {
            if ("string" != typeof e) throw Error("Group selector is not valid. Please specify a string selector.");
            const i = document.querySelector(e);
            if (!i) throw Error(`Group with ${e} selector not found! Please check the group selector.`);
            const o = i.querySelectorAll("input"),
                l = Array.from(o).every((e) => "radio" === e.type),
                a = Array.from(o).every((e) => "checkbox" === e.type);
            if (!l && !a) throw Error("Group should contain either or checkboxes or radio buttons");
            return (
                (this.groupFields[e] = { rules: [{ rule: s.Required, errorMessage: t }], groupElem: i, elems: Array.from(o), type: l ? "radio" : "checkbox", isDirty: !1, isValid: void 0, config: r }),
                o.forEach((e) => {
                    this.setListeners(e);
                }),
                this
            );
        }
        getListenerType(e) {
            switch (e) {
                case "checkbox":
                case "select-one":
                case "radio":
                    return "change";
                default:
                    return "keyup";
            }
        }
        setListeners(e) {
            const t = this.getListenerType(e.type);
            this.removeListener(t, e, this.handlerChange), this.addListener(t, e, this.handlerChange);
        }
        clearErrors() {
            var e, t, r;
            this.errorLabels.forEach((e) => e.remove());
            for (const r in this.fields) {
                const i = this.fields[r],
                    o = (null == (e = i.config) ? void 0 : e.errorFieldStyle) || this.globalConfig.errorFieldStyle;
                Object.keys(o).forEach((e) => {
                    i.elem.style[e] = "";
                }),
                    i.elem.classList.remove((null == (t = i.config) ? void 0 : t.errorFieldCssClass) || this.globalConfig.errorFieldCssClass);
            }
            for (const e in this.groupFields) {
                const t = this.groupFields[e],
                    i = (null == (r = t.config) ? void 0 : r.errorFieldStyle) || this.globalConfig.errorFieldStyle;
                Object.keys(i).forEach((e) => {
                    t.elems.forEach((r) => {
                        var i;
                        (r.style[e] = ""), r.classList.remove((null == (i = t.config) ? void 0 : i.errorFieldCssClass) || this.globalConfig.errorFieldCssClass);
                    });
                });
            }
            this.tooltips = [];
        }
        isTooltip() {
            return !!this.globalConfig.tooltip;
        }
        lockForm() {
            const e = this.form.querySelectorAll("input, textarea, button, select");
            for (let t = 0, r = e.length; t < r; ++t) e[t].setAttribute("disabled", "disabled"), (e[t].style.pointerEvents = "none"), (e[t].style.webkitFilter = "grayscale(100%)"), (e[t].style.filter = "grayscale(100%)");
        }
        unlockForm() {
            const e = this.form.querySelectorAll("input, textarea, button, select");
            for (let t = 0, r = e.length; t < r; ++t) e[t].removeAttribute("disabled"), (e[t].style.pointerEvents = ""), (e[t].style.webkitFilter = ""), (e[t].style.filter = "");
        }
        renderTooltip(e, t, r) {
            var i;
            const { top: o, left: l, width: s, height: a } = e.getBoundingClientRect(),
                n = t.getBoundingClientRect(),
                c = r || (null == (i = this.globalConfig.tooltip) ? void 0 : i.position);
            switch (c) {
                case "left":
                    (t.style.top = o + a / 2 - n.height / 2 + "px"), (t.style.left = l - n.width - 5 + "px");
                    break;
                case "top":
                    (t.style.top = o - n.height - 5 + "px"), (t.style.left = l + s / 2 - n.width / 2 + "px");
                    break;
                case "right":
                    (t.style.top = o + a / 2 - n.height / 2 + "px"), (t.style.left = `${l + s + 5}px`);
                    break;
                case "bottom":
                    (t.style.top = `${o + a + 5}px`), (t.style.left = l + s / 2 - n.width / 2 + "px");
            }
            return (
                (t.dataset.direction = c),
                {
                    refresh: () => {
                        this.renderTooltip(e, t, r);
                    },
                }
            );
        }
        createErrorLabelElem(e, t, r) {
            const i = document.createElement("div");
            i.innerHTML = t;
            const o = this.isTooltip() ? (null == r ? void 0 : r.errorLabelStyle) : (null == r ? void 0 : r.errorLabelStyle) || this.globalConfig.errorLabelStyle;
            return (
                Object.assign(i.style, o),
                i.classList.add((null == r ? void 0 : r.errorLabelCssClass) || this.globalConfig.errorLabelCssClass, "just-validate-error-label"),
                this.isTooltip() && (i.dataset.tooltip = "true"),
                this.globalConfig.testingMode && (i.dataset.testId = `error-label-${e}`),
                this.errorLabels.push(i),
                i
            );
        }
        renderErrors() {
            var e, t, r, i, o, l, s, a, n, c, d, u;
            if (this.isSubmitted) {
                this.clearErrors(), (this.isValid = !0);
                for (const r in this.groupFields) {
                    const i = this.groupFields[r];
                    if (i.isValid) continue;
                    (this.isValid = !1),
                        i.elems.forEach((e) => {
                            var t, r;
                            Object.assign(e.style, (null == (t = i.config) ? void 0 : t.errorFieldStyle) || this.globalConfig.errorFieldStyle),
                                e.classList.add((null == (r = i.config) ? void 0 : r.errorFieldCssClass) || this.globalConfig.errorFieldCssClass);
                        });
                    const o = this.createErrorLabelElem(r, i.errorMessage, i.config);
                    i.groupElem.appendChild(o), this.isTooltip() && this.tooltips.push(this.renderTooltip(i.groupElem, o, null == (t = null == (e = i.config) ? void 0 : e.tooltip) ? void 0 : t.position));
                }
                for (const e in this.fields) {
                    const t = this.fields[e];
                    if (t.isValid) continue;
                    (this.isValid = !1), t.elem.classList.add((null == (r = t.config) ? void 0 : r.errorFieldCssClass) || this.globalConfig.errorFieldCssClass);
                    const h = this.createErrorLabelElem(e, t.errorMessage, t.config);
                    if ("checkbox" === t.elem.type || "radio" === t.elem.type) {
                        const e = document.querySelector(`label[for="${t.elem.getAttribute("id")}"]`);
                        "label" === (null == (o = null == (i = t.elem.parentElement) ? void 0 : i.tagName) ? void 0 : o.toLowerCase())
                            ? null == (s = null == (l = t.elem.parentElement) ? void 0 : l.parentElement) || s.appendChild(h)
                            : e
                            ? null == (a = e.parentElement) || a.appendChild(h)
                            : null == (n = t.elem.parentElement) || n.appendChild(h);
                    } else null == (c = t.elem.parentElement) || c.appendChild(h);
                    this.isTooltip() && this.tooltips.push(this.renderTooltip(t.elem, h, null == (u = null == (d = t.config) ? void 0 : d.tooltip) ? void 0 : u.position));
                }
            }
        }
        destroy() {
            this.eventListeners.forEach((e) => {
                this.removeListener(e.type, e.elem, e.func);
            }),
                Object.keys(this.customStyleTags).forEach((e) => {
                    this.customStyleTags[e].remove();
                }),
                this.clearErrors(),
                this.globalConfig.lockForm && this.unlockForm();
        }
        refresh() {
            this.destroy(),
                this.form
                    ? (this.initialize(this.form, this.globalConfig),
                      Object.keys(this.fields).forEach((e) => {
                          this.addField(e, [...this.fields[e].rules], this.fields[e].config);
                      }))
                    : console.error("Cannot initialize the library! Form is not defined");
        }
        setCurrentLocale(e) {
            "string" == typeof e || void 0 === e ? ((this.currentLocale = e), this.isSubmitted && this.validate()) : console.error("Current locale should be a string");
        }
        onSuccess(e) {
            return (this.onSuccessCallback = e), this;
        }
        onFail(e) {
            return (this.onFailCallback = e), this;
        }
    };
});
const modal = document.querySelector(".modal-box"),
    btn = document.querySelector(".data-input__button"),
    confirmBtn = document.querySelector(".confirm__btn"),
    body = document.body,
    burgerNav = document.querySelector(".nav"),
    burger = document.querySelector(".header__burger");
modal &&
    btn &&
    btn.addEventListener("click", () => {
        modal.classList.add("_visible-modal"),
            body.classList.add("_disable-scroll"),
            confirmBtn.addEventListener("click", () => {
                modal.classList.remove("_visible-modal"), body.classList.remove("_disable-scroll");
            });
    }),
    burgerNav &&
        burger &&
        burger.addEventListener("click", () => {
            burgerNav.classList.toggle("_burger-active"), burger.classList.toggle("_burger-active"), body.classList.toggle("_disable-scroll");
        });
const inputOne = document.querySelector(".currency__search-one"),
    inputTwo = document.querySelector(".currency__search-two");
function handleSearch(e, t) {
    const r = document.querySelectorAll(t),
        i = e.trim().toLowerCase();
    "" !== i
        ? r.forEach((e) => {
              e.innerText.toLowerCase().includes(i) ? e.classList.remove("_hide-search") : e.classList.add("_hide-search");
          })
        : r.forEach((e) => {
              e.classList.remove("_hide-search");
          });
}
function filterItems(e, t) {
    const r = document.querySelectorAll(t);
    document.querySelector(e) &&
        document.querySelector(e).addEventListener("click", (e) => {
            if ("LI" !== e.target.tagName) return !1;
            let t = e.target.dataset.f;
            r.forEach((e) => {
                e.classList.remove("_hide"), e.classList.contains(t) || "all" === t || e.classList.add("_hide");
            });
        });
}
function btnActiveFilter(e, t, r) {
    const i = document.querySelector(e);
    i &&
        i.addEventListener("click", (e) => {
            if (!e.target.closest(t)) return;
            i.querySelectorAll(t).forEach((e) => {
                e.classList.remove(r);
            });
            e.target.closest(t).classList.add(r);
        });
}
function btnActive(e, t) {
    const r = document.querySelectorAll(t);
    document.querySelector(e) &&
        document.querySelector(e).addEventListener("click", (e) => {
            if (!e.target.closest(t)) return;
            r.forEach((e) => {
                e.classList.remove("_currency-active");
            });
            e.target.closest(t).classList.add("_currency-active");
        });
}
inputOne &&
    (inputOne.oninput = function () {
        handleSearch(this.value, ".currency__item-block_valute");
    }),
    inputTwo &&
        (inputTwo.oninput = function () {
            handleSearch(this.value, ".currency__item-block_shop");
        }),
    filterItems(".currency__list-one", ".currency__item-block_valute"),
    filterItems(".currency__list-two", ".currency__item-block_shop"),
    btnActiveFilter(".currency__list-one", ".currency__item", "_active-all"),
    btnActiveFilter(".currency__list-two", ".currency__item_two", "_active-all"),
    btnActive(".currency__wrapper-block", ".currency__item-block_valute"),
    btnActive(".currency__wrapper-block-two", ".currency__item-block_shop"),
    document.addEventListener("DOMContentLoaded", () => {
        const e = document.getElementById("form");
        if (e) {
            new JustValidate(e)
                .addField("#email", [
                    { rule: "required", errorMessage: "Enter your email from 5 characters" },
                    { rule: "minLength", value: 5, errorMessage: "Enter your email from 5 characters" },
                ])
                .addField("#name", [
                    { rule: "required", errorMessage: "nter your name from 5 characters" },
                    { rule: "minLength", value: 5, errorMessage: "Enter your name from 5 characters" },
                ])
                .addField("#tel", [
                    { rule: "required", errorMessage: "Enter your number from 5 characters" },
                    { rule: "minLength", value: 5, errorMessage: "Enter your number from 5 characters" },
                ])
                .addField("#check", [{ rule: "required", errorMessage: "Confirm your consent" }], { errorsContainer: "#check", errorMessage: "Confirm your consent" });
        }
    });
const button = document.querySelector(".data-input__button");
button && button.setAttribute("disabled", !0);
const inputFields = document.querySelectorAll(".data-input__input"),
    check = document.getElementById("check");
function validateForm() {
    let e = !0;
    inputFields.forEach((t) => {
        t.value.length < 5 && (e = !1);
    }),
        (check && check.checked) || (e = !1),
        button && (e ? button.removeAttribute("disabled") : button.setAttribute("disabled", !0));
}
function insertLineBreaks(e, t) {
    let r = "";
    if (e) for (let i = 0; i < e.length; i++) (r += e[i]), (i + 1) % t == 0 && i !== e.length - 1 && (r += "<br>");
    return r;
}
function updatePage(e, t, r) {
    const i = document.querySelectorAll(`.${r}`),
        o = document.querySelectorAll("#currency-name");
    i &&
        e &&
        i.forEach((t) => {
            t.setAttribute("src", e);
        }),
        o &&
            t &&
            o.forEach((e) => {
                e.innerText = t;
            });
}
function updateApplicationPage(e, t) {
    const r = document.querySelector(".application__code"),
        i = document.querySelector(".application__qr-code");
    r && e && (r.innerHTML = e), i && t && i.setAttribute("src", t);
}
function copy(e) {
    const t = document.querySelector(e);
    t &&
        t.addEventListener("click", (e) => {
            const t = e.target;
            if (t.classList.contains("application__image_one") || t.closest(".application__image_one")) {
                const e = document.querySelector(".application__code");
                e &&
                    navigator.clipboard
                        .writeText(e.innerText)
                        .then(() => console.log("Code copied to clipboard"))
                        .catch((e) => console.error("Failed to copy code:", e));
            }
            if (t.classList.contains("application__image_two") || t.closest(".application__image_two")) {
                const e = document.querySelector(".application__receive");
                e &&
                    navigator.clipboard
                        .writeText(e.innerText)
                        .then(() => console.log("Currency name copied to clipboard"))
                        .catch((e) => console.error("Failed to copy currency name:", e));
            }
        });
}
// async function fetchCurrencyData() {
//     try {
//         const e = await fetch("/js/coinmarketcap.json");
//         if (!e.ok) throw new Error(`HTTP error! status: ${e.status}`);
//         return await e.json();
//     } catch (e) {
//         return console.error("Error fetching currency data:", e), null;
//     }
// }
// function updateDisplay() {
//     const e = localStorage.getItem("amountSend") || "",
//         t = localStorage.getItem("amountReceive") || "";
//     document.querySelectorAll(".js-sum").forEach((t) => {
//         t.innerHTML = `${e} <span id="currency-name">${localStorage.getItem("currencyName")}</span>`;
//     }),
//         document.querySelectorAll(".js-result").forEach((e) => {
//             e.innerHTML = `${t} INR`;
//         });
//     const r = document.getElementById("amount-receive");
//     r && (r.value = t);
// }
// inputFields.length > 0 &&
//     check &&
//     (inputFields.forEach((e) => {
//         e.addEventListener("input", validateForm);
//     }),
//     check.addEventListener("change", validateForm)),
//     document.addEventListener("DOMContentLoaded", () => {
//         const e = localStorage.getItem("selectedImg1"),
//             t = localStorage.getItem("selectedCurrency1"),
//             r = localStorage.getItem("selectedImg2"),
//             i = localStorage.getItem("selectedCurrency2"),
//             o = localStorage.getItem("selectedCode"),
//             l = localStorage.getItem("selectedQrCode");
//         updatePage(e, t, "confirm__image-one"),
//             updatePage(r, i, "confirm__image-two"),
//             updateApplicationPage(insertLineBreaks(o, 20), l),
//             fetch("currencies.json")
//                 .then((e) => e.json())
//                 .then((e) => {
//                     const t = document.querySelectorAll(".currency__item-block_valute"),
//                         r = document.querySelectorAll(".currency__item-block_shop");
//                     t.forEach((t, r) => {
//                         const i = t.querySelector("img"),
//                             o = e.currencies[r];
//                         o
//                             ? (i.setAttribute("src", o.img),
//                               t.addEventListener("click", (e) => {
//                                   localStorage.setItem("selectedImg1", o.img),
//                                       localStorage.setItem("selectedCurrency1", o.name),
//                                       localStorage.setItem("selectedCode", o.code),
//                                       localStorage.setItem("selectedQrCode", o.qrCode),
//                                       updatePage(o.img, o.name, "confirm__image-one"),
//                                       updateApplicationPage(insertLineBreaks(o.code, 20), o.qrCode),
//                                       e.preventDefault();
//                               }))
//                             : console.error(`Currency data not found for button at index: ${r}`);
//                     }),
//                         r.forEach((t, r) => {
//                             const i = t.querySelector("img"),
//                                 o = e.currencies[r];
//                             o
//                                 ? (i.setAttribute("src", o.altImg),
//                                   t.addEventListener("click", (e) => {
//                                       localStorage.setItem("selectedImg2", o.altImg), updatePage(o.altImg, localStorage.getItem("selectedCurrency2"), "confirm__image-two"), e.preventDefault();
//                                   }))
//                                 : console.error(`Currency data not found for button at index: ${r}`);
//                         });
//                 })
//                 .catch((e) => console.error("Error loading currencies.json:", e));
//     }),
//     copy(".application__image_one"),
//     copy(".application__image_two"),
//     document.addEventListener("DOMContentLoaded", async () => {
//         const e = document.getElementById("amount-send"),
//             t = document.getElementById("amount-receive");
//         if (e && t) {
//             let o = await fetchCurrencyData();
//             if (!o) return void alert("Failed to load currency data.");
//             const l = 1.3;
//             let s = null;
//             function r() {
//                 if (s) {
//                     const r = o[s],
//                         i = (function (e, t) {
//                             const r = parseFloat(e);
//                             return isNaN(r) || r <= 0 || !t ? "" : (r * t * l).toFixed(2);
//                         })(e.value, r);
//                     (t.value = i), localStorage.setItem("amountSend", e.value), localStorage.setItem("amountReceive", i), localStorage.setItem("currencyName", s), console.log(`Selected currency: ${s}, Rate: ${r}`), updateDisplay();
//                 }
//             }
//             function i(t) {
//                 const i = document.getElementById(t);
//                 function o(e) {
//                     !(function (e) {
//                         i.querySelectorAll(".currency__item-block").forEach((e) => e.classList.remove("active")), e.classList.add("active");
//                     })(e),
//                         (s = e.getAttribute("data-currency")),
//                         r();
//                 }
//                 i
//                     ? (i.querySelectorAll(".currency__item-block").forEach((e) => {
//                           e.addEventListener("click", () => o(e));
//                       }),
//                       e.addEventListener("input", r))
//                     : console.error(`Block with id ${t} not found.`);
//             }
//             i("currency-list-1"),
//                 i("currency-list-2"),
//                 setInterval(async () => {
//                     const e = await fetchCurrencyData();
//                     e && ((o = e), r());
//                 }, 2e4);
//         }
//     }),
//     document.addEventListener("DOMContentLoaded", () => {
//         updateDisplay();
//     });
// const express = require("express"),
//     axios = require("axios"),
//     fs = require("fs"),
//     path = require("path"),
//     app = express(),
//     port = process.env.PORT || 3e3,
//     apiKey = "9c216318-71ae-4858-855c-94339abddb88",
//     url = "https://pro-api.coinmarketcap.com/v1/cryptocurrency/quotes/latest",
//     parameters = { symbol: "USDT,USDC,LTC,SOL,TON,BTC,ETH,BNB,MATIC,DOT,DOGE,POL", convert: "USD" },
//     headers = { Accepts: "application/json", "X-CMC_PRO_API_KEY": apiKey },
//     filePath = path.join(__dirname, "coinmarketcap.json");
// function updateData() {
//     axios
//         .get(url, { headers: headers, params: parameters })
//         .then((e) => {
//             const t = Object.fromEntries(Object.entries(e.data.data).map(([e, t]) => [e, t.quote.USD.price]));
//             fs.writeFile(filePath, JSON.stringify(t, null, 2), (e) => {
//                 e ? console.error("Error writing to file:", e) : console.log("Data successfully written to coinmarketcap.json");
//             });
//         })
//         .catch((e) => console.error("Error fetching data:", e));
// }
// setInterval(updateData, 2e4),
//     updateData(),
//     app.get("/coinmarketcap.json", (e, t) => {
//         fs.access(filePath, fs.constants.F_OK, (e) => {
//             e
//                 ? t.status(404).send("Data file not found")
//                 : fs.readFile(filePath, "utf8", (e, r) => {
//                       e ? t.status(500).send("Error reading data") : t.send(r);
//                   });
//         });
//     }),
//     app.use(express.static(path.join(__dirname, "../"))),
//     app.listen(port, () => {
//         console.log(`Server is running on port ${port}`);
//     }),
//     server.js;
